
* Project Overview
This project demonstrates the integration of the F' (F Prime) flight software framework with Zephyr RTOS in an comprehensively illustrative yet approachable application.

By combining F' and Zephyr, this project offers a solid foundation for flight software and other critical embedded applications with formal interfaces, robust architecture, and broad hardware compatibility.

The project structure includes:
+ An [[https://fprime.jpl.nasa.gov/latest/docs/user-manual/overview/proj-dep/][F' deployment]] found @ ~./FlightSoftware~:
  Contains the F' application configuration and deployment-specific code
  This linux application leverages both standard and custom components to sample data via a UDP connection and propagates that data to it's internal components (which can be interfaced with via the [[https://fprime.jpl.nasa.gov/latest/docs/user-manual/overview/gds-introduction/][F' ground control system, fprime-gds]]).
+ ~Components~: Demonstrates how generic F' components can be integrated (currently just a simple LED component)
+ ~bare-zephyr-app~: A minimal Zephyr-only implementation for comparison with the F' approach
+ A developer environment interfaced with via ~./run.sh~.
  This bash script orchestrates the above mentioned applications within a virtual environment for building, running and testing purposes.


The following [[https://c4model.com/diagrams/container][C4 container diagram]] illustrates the relationships between these functional components.

#+begin_src plantuml :file .assets/project_overview.png :tangle .assets/project_overview.puml :exports results
@startuml F' Zephyr Component Diagram

!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml
!define ICONURL https://raw.githubusercontent.com/tupadr3/plantuml-icon-font-sprites/v3.0.0/icons
!include ICONURL/font-awesome-5/microchip.puml
!include ICONURL/font-awesome-5/desktop.puml
!include ICONURL/font-awesome-5/download.puml
!include ICONURL/font-awesome-5/broadcast_tower.puml
!include ICONURL/font-awesome-5/cube.puml
!include ICONURL/font-awesome-5/network_wired.puml
!include ICONURL/font-awesome-5/cubes.puml
!include ICONURL/material/settings_ethernet.puml
!include ICONURL/material/vertical_align_bottom.puml
!include ICONURL/material/vertical_align_top.puml
!include ICONURL/material/lightbulb_outline.puml
!include ICONURL/govicons/world.puml
!include ICONURL/material/usb.puml
!include ICONURL/font-awesome-5/user.puml

title "F' Zephyr Reference Application - Component Architecture"

Component(app, "app", "Zephyr Executable", "Main application binary")

Container_Boundary(fprimeDeployment, "F' Deployment") {
    Component(baseDeploymentTop, "BaseDeployment_Top", "F' Topology", "Instatiates and configures F' components", $sprite="network_wired")
    Component(ledComponent, "LED Component", "F' Component", "Controls LED hardware", $sprite="lightbulb_outline")
}

Container_Boundary(fprimeFramework, "F' Framework") {
    Component(autocoder, "F' Autocoder", "Code Generator", "Generates C++ from FPP specifications")
    Component(coreComponents, "F' Core Components", "Framework Services", "Core F' components and services")
}

Container_Boundary(zephyrRTOS, "Zephyr RTOS") {
    Component(zephyrInterface, "zephyr_interface", "Interface Library", "Provides access to Zephyr APIs")
}

' Relationships
Rel(app, baseDeploymentTop, "links to")
Rel(baseDeploymentTop, components, "uses")
Rel(components, ledComponent, "includes")
Rel(baseDeploymentTop, zephyrInterface, "links to")
Rel(components, autocoder, "generated by")
Rel(baseDeploymentTop, coreComponents, "uses")

' Build Process Relationships
Rel_U(app, autocoder, "built with")

@enduml
#+end_src

#+RESULTS:
[[file:.assets/project_overview.png]]

** Developer Tools and Usage

*** Development Environment
This project leverages Docker to provide a consistent development environment with all necessary dependencies pre-installed. The included tooling supports:
- Building for multiple target boards
- Deploying applications to hardware
- Testing and monitoring via F' Ground Data System (GDS)
- FPP modeling and code generation

*** Building the Application
To build the application for a specific board (Teensy 4.1 used as example):

#+begin_src sh
# Using the convenience script
./run.sh generate teensy41
./run.sh build

# Or manually with fprime-util
fprime-util generate -DBOARD=teensy41
fprime-util build -j4
#+end_src

To switch to a different target board:

#+begin_src sh
# Clear previous build artifacts first
fprime-util purge zephyr -f
# Then generate for new board
fprime-util generate -DBOARD=new_board_name
fprime-util build -j4
#+end_src

Board-specific configurations can be managed through the ~proj.conf~ file and board overlay files in the ~boards/~ directory.

*** Uploading to Hardware
After building, locate the correct binary format for your board in ~build-fprime-automatic-zephyr/zephyr/~:
- ~zephyr.bin~, ~zephyr.elf~, ~zephyr.hex~, ~zephyr.uf2~, etc.

Upload using the appropriate method for your board (e.g., for Teensy, the Teensy Loader application).

*** Running the Ground System
To connect to the device for monitoring and commanding:

#+begin_src sh
# First ensure you have access to serial device
sudo chmod 0777 /dev/ttyACM0

# Start the Ground Data System
fprime-gds -n --dictionary ./build-artifacts/zephyr/LedBlinker/dict/LedBlinkerTopologyAppDictionary.xml --comm-adapter uart --uart-device /dev/ttyACM0 --uart-baud 115200
#+end_src

*** Component Development
To create new components:
1. Define component interfaces in FPP (~.fpp~ files)
2. Generate component templates with ~fprime-util generate-template~
3. Implement component functionality in C++
4. Add components to the topology in ~Top.fpp~
5. Rebuild the project

*** Using the Docker Environment
The included ~run.sh~ script provides a convenient way to work within the Docker environment:

#+begin_src sh
# Enter shell in the Docker container
./run.sh shell

# Build the project
./run.sh build

# Run GDS
./run.sh gds

# Clean build artifacts
./run.sh clean
#+end_src
